<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>表形式データ相互変換ツール</title>
    <style>
        body {
            font-family: sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 1200px;
            margin: 20px auto;
            padding: 0 15px;
        }

        h1,
        h2 {
            border-bottom: 2px solid #007bff;
            padding-bottom: 5px;
        }

        .container {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .input-area,
        .output-area {
            display: flex;
            flex-direction: column;
        }

        textarea {
            width: 100%;
            height: 200px;
            padding: 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            font-family: monospace;
            font-size: 14px;
            box-sizing: border-box;
        }

        button {
            background-color: #007bff;
            color: white;
            border: none;
            padding: 10px 15px;
            margin: 5px 2px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
        }

        button:hover {
            background-color: #0056b3;
            color: #f1f1f1;
        }


        button.tab-button.active {
            color: #606060;
        }

        .editor-container {
            margin-top: 10px;
            border: 1px solid #ccc;
            padding: 10px;
            border-radius: 4px;
            max-height: 400px;
            overflow: auto;
        }

        table {
            border-collapse: collapse;
            width: 100%;
        }

        th,
        td {
            border: 1px solid #ddd;
            padding: 8px;
            text-align: left;
        }

        th {
            background-color: #f2f2f2;
        }

        td input {
            width: 100%;
            border: 1px solid transparent;
            padding: 6px;
            box-sizing: border-box;
        }

        td input:focus {
            outline: 1px solid #007bff;
            background-color: #f9f9f9;
        }

        .controls {
            margin-bottom: 10px;
        }

        .tab-buttons {
            margin-bottom: 15px;
            border-bottom: 1px solid #ccc;
        }

        .tab-button {
            padding: 10px 15px;
            cursor: pointer;
            border: 1px solid transparent;
            border-bottom: none;
            margin-bottom: -1px;
            color: #666;
            background-color: #ddd;
            /* #f1f1f1; */
        }


        .tab-button.active {
            background-color: #fff;
            border-color: #ccc;
            border-bottom-color: #fff;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }
    </style>
</head>

<body>

    <h1>表形式データ相互変換ツール 試験運用版</h1>

    <div class="tab-buttons">
        <button class="tab-button active" onclick="openTab(event, 'A')">(A) 表データから生成</button>
        <button class="tab-button" onclick="openTab(event, 'B')">(B) Markdownから変換</button>
        <button class="tab-button" onclick="openTab(event, 'C')">(C) TeXから変換</button>
    </div>

    <div id="A" class="tab-content active">
        <h2>(A) 表データから各種コードを生成</h2>
        <p>表計算ソフトからコピーしたデータ（タブ区切り）などを貼り付けてください。</p>
        <p>【詳細】
            区切り方は，タブ区切りが最優先で判定されます（タブ区切り→カンマ区切り）。データ中にタブを含む場合はタブ区切りとして認識されます。<br>
            カンマ区切りのデータの場合，内部にカンマを含むセルについては，分割されないようにそのセルの中身を丸ごと""で囲んでください。</p>
        <div class="container">
            <div class="input-area">
                <label for="plain-input">入力データ:</label>
                <textarea id="plain-input" placeholder="ヘッダー1	ヘッダー2
Cell1	Cell2"></textarea>
                <button onclick="generateTableEditor()">表を生成・編集</button>
            </div>
            <div class="output-area">
                <label>出力コード:</label>
                <textarea id="plain-output" readonly></textarea>
                <div>
                    <button onclick="generateFromEditor('markdown')">Markdown生成</button>
                    <button onclick="generateFromEditor('tex')">TeX生成</button>
                </div>
            </div>
        </div>
        <div class="controls">
            <button onclick="addRow()">行を追加</button>
            <button onclick="removeRow()">最後の行を削除</button>
            <button onclick="addCol()">列を追加</button>
            <button onclick="removeCol()">最後の列を削除</button>
        </div>
        <div id="table-editor" class="editor-container"></div>
    </div>

    <div id="B" class="tab-content">
        <h2>(B) Markdownの表を変換</h2>
        <p>Markdown形式の表コードを貼り付けてください。</p>
        <div class="container">
            <div class="input-area">
                <label for="md-input">Markdown入力:</label>
                <textarea id="md-input"
                    placeholder="| Header 1 | Header 2 |&#10;|----------|----------|&#10;| Cell 1   | Cell 2   |"></textarea>
                <button onclick="convertFromMarkdown()">変換</button>
            </div>
            <div class="output-area">
                <label>出力コード (TeX):</label>
                <textarea id="md-output-tex" readonly></textarea>
                <label style="margin-top: 10px;">プレビューとコピー用:</label>
                <div id="md-preview" class="editor-container"></div>
            </div>
        </div>
    </div>

    <div id="C" class="tab-content">
        <h2>(C) TeXの表を変換</h2>
        <p>TeXのtabular環境のコードを貼り付けてください。
            （tabular環境の入れ子は1回のみ対応。また，左揃え・中揃え・右揃えの情報などは消えます）</p>
        <div class="container">
            <div class="input-area">
                <label for="tex-input">TeX入力:</label>
                <textarea id="tex-input"
                    placeholder="\begin{tabular}{cc}&#10;Header 1 & Header 2 \\&#10;\hline&#10;Cell 1 & Cell 2 &percnt;コメントは残ります\\&#10;\end{tabular}"></textarea>
                <button onclick="convertFromTex()">変換</button>
            </div>
            <div class="output-area">
                <label>出力コード (Markdown):</label>
                <textarea id="tex-output-md" readonly></textarea>
                <label style="margin-top: 10px;">プレビューとコピー用:</label>
                <div id="tex-preview" class="editor-container"></div>
            </div>
        </div>
    </div>

    <div id="footer" style="text-align: center; margin-top: 20px; font-size: small;">
        <p>Last Updated Date: 2025-08-18. <br>
            このHTMLをローカル環境に保存しても実行は可能であるはずです．<br>
            なお，本スクリプトはあくまで自分の作業の効率化のために作成したものであり，自分の都合で変更・削除することがあります．<br>
            本スクリプト実行時の動作の不具合については責任を取りかねますことご容赦ください．
            <!-- researchmap.jp/y-zaki -->
        </p>
    </div>

    <script>
        // --- 汎用関数 & 状態管理 ---
        let tableData = []; // アプリケーション全体で使うデータストア (2次元配列)

        function updateTableEditor() {
            const editor = document.getElementById('table-editor');
            if (!editor || tableData.length === 0) {
                editor.innerHTML = '';
                return;
            }

            const table = document.createElement('table');
            const tbody = document.createElement('tbody');

            tableData.forEach((rowData, rowIndex) => {
                const tr = document.createElement('tr');
                rowData.forEach((cellData, colIndex) => {
                    const td = document.createElement('td');
                    const input = document.createElement('input');
                    input.type = 'text';
                    input.value = cellData;
                    input.onchange = () => {
                        tableData[rowIndex][colIndex] = input.value;
                    };
                    td.appendChild(input);
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });
            table.appendChild(tbody);
            editor.innerHTML = '';
            editor.appendChild(table);
        }

        function renderPreview(elementId, data) {
            const container = document.getElementById(elementId);
            if (data.length === 0) {
                container.innerHTML = '<p>データがありません。</p>';
                return;
            }

            const table = document.createElement('table');
            const thead = document.createElement('thead');
            const tbody = document.createElement('tbody');

            // ヘッダー
            const headerRow = document.createElement('tr');
            data[0].forEach(headerText => {
                const th = document.createElement('th');
                th.textContent = headerText;
                headerRow.appendChild(th);
            });
            thead.appendChild(headerRow);

            // データ行
            data.slice(1).forEach(rowData => {
                const tr = document.createElement('tr');
                rowData.forEach(cellText => {
                    const td = document.createElement('td');
                    td.textContent = cellText;
                    tr.appendChild(td);
                });
                tbody.appendChild(tr);
            });

            table.appendChild(thead);
            table.appendChild(tbody);
            container.innerHTML = '';
            container.appendChild(table);
        }

        // --- タブ切り替え ---
        function openTab(evt, tabName) {
            let i, tabcontent, tablinks;
            tabcontent = document.getElementsByClassName("tab-content");
            for (i = 0; i < tabcontent.length; i++) {
                tabcontent[i].style.display = "none";
            }
            tablinks = document.getElementsByClassName("tab-button");
            for (i = 0; i < tablinks.length; i++) {
                tablinks[i].className = tablinks[i].className.replace(" active", "");
            }
            document.getElementById(tabName).style.display = "block";
            evt.currentTarget.className += " active";
        }

        // --- (A) プレーンテキストからの変換機能 ---
        /**
        * CSVの1行を解析し、セルの配列を返す補助関数
        * ダブルクォートで囲まれた中のカンマを無視し、エスケープされたダブルクォート(""")も考慮します。
        * @param {string} rowString - CSVの1行の文字列
        * @returns {string[]} - セルの配列
        */
        function parseCsvRow(rowString) {
            const cells = [];
            let currentCell = '';
            let inQuotes = false;

            for (let i = 0; i < rowString.length; i++) {
                const char = rowString[i];

                if (char === '"') {
                    // ダブルクォートが2つ続く場合 (CSVにおける " のエスケープ)
                    if (inQuotes && rowString[i + 1] === '"') {
                        currentCell += '"';
                        i++; // 次の文字をスキップ
                    } else {
                        // 通常のダブルクォートは、引用モードの開始/終了
                        inQuotes = !inQuotes;
                    }
                } else if (char === ',' && !inQuotes) {
                    // 引用モードでない時にカンマがあれば、セルを確定
                    cells.push(currentCell);
                    currentCell = '';
                } else {
                    // それ以外の文字は現在のセルに追加
                    currentCell += char;
                }
            }
            cells.push(currentCell); // 最後のセルを追加

            // 各セルから、もしあれば前後の空白とセルを囲むクォートを削除
            return cells.map(cell => {
                const trimmedCell = cell.trim();
                if (trimmedCell.startsWith('"') && trimmedCell.endsWith('"')) {
                    // クォートを剥がし、内部のエスケープされたクォート("" -> ")を元に戻す
                    return trimmedCell.substring(1, trimmedCell.length - 1).replace(/""/g, '"');
                }
                return trimmedCell;
            });
        }

        function generateTableEditor() {
            const text = document.getElementById('plain-input').value.trim();
            if (!text) {
                alert('入力データが空です。');
                return;
            }

            const rows = text.split('\n');

            // 区切り文字を判定し、カンマ区切り(CSV)の場合のみ新しいパーサーを使う
            const isTsv = text.includes('\t');
            const isCsv = !isTsv && text.includes(',');

            if (isCsv) {
                // カンマ区切りの場合は、クォートを考慮したCSVパーサーを使用
                tableData = rows.map(row => parseCsvRow(row));
            } else {
                // それ以外（タブやスペース区切り）は従来のシンプルなsplitを使用
                const delimiter = isTsv ? '\t' : /\s+/;
                tableData = rows.map(row => row.split(delimiter).map(cell => cell.trim()));
            }

            updateTableEditor();
        }

        function addRow() {
            if (tableData.length === 0) return;
            const newRow = Array(tableData[0].length).fill('');
            tableData.push(newRow);
            updateTableEditor();
        }

        function removeRow() {
            if (tableData.length > 1) {
                tableData.pop();
                updateTableEditor();
            }
        }

        function addCol() {
            if (tableData.length === 0) return;
            tableData.forEach(row => row.push(''));
            updateTableEditor();
        }

        function removeCol() {
            if (tableData.length === 0 || tableData[0].length <= 1) return;
            tableData.forEach(row => row.pop());
            updateTableEditor();
        }

        function generateFromEditor(format) {
            if (tableData.length === 0) {
                alert('まず表を生成してください。');
                return;
            }
            let output = '';
            if (format === 'markdown') {
                output = generateMarkdown(tableData);
            } else if (format === 'tex') {
                output = generateTex(tableData);
            }
            document.getElementById('plain-output').value = output;
        }

        // --- (B) Markdownからの変換機能 ---
        function convertFromMarkdown() {
            const mdText = document.getElementById('md-input').value.trim();
            try {
                const data = parseMarkdown(mdText);
                if (data.length === 0) throw new Error("Markdownの解析に失敗しました。");
                document.getElementById('md-output-tex').value = generateTex(data);
                renderPreview('md-preview', data);
            } catch (e) {
                alert(e.message);
            }
        }

        // --- (C) TeXからの変換機能 ---
        function convertFromTex() {
            const texText = document.getElementById('tex-input').value.trim();
            try {
                const data = parseTex(texText);
                if (data.length === 0) throw new Error("TeXの解析に失敗しました。");
                document.getElementById('tex-output-md').value = generateMarkdown(data);
                renderPreview('tex-preview', data);
            } catch (e) {
                alert(e.message);
            }
        }

        // --- パーサー（文字列 -> 2次元配列） ---
        function parseMarkdown(text) {
            const lines = text.split('\n').map(l => l.trim()).filter(l => l.startsWith('|'));
            if (lines.length < 2) return [];

            const table = lines
                .map(line => line.split('|').slice(1, -1).map(cell => cell.trim()));

            // 区切り行(---)を除外
            if (table.length > 1 && table[1].every(cell => /^-+$/.test(cell))) {
                table.splice(1, 1);
            }
            return table;
        }

        // 改善版の parseTex 関数 (入れ子内の改行を処理)
        function parseTex(text) {
            // --- Step 1: Outermost tabular content extraction using a nesting counter ---
            let nestingLevel = 0;
            let contentStartIndex = -1;
            let contentEndIndex = -1;
            let searchIndex = 0;

            const beginTag = /\\begin{tabular}/g;
            const endTag = /\\end{tabular}/g;

            const firstMatch = beginTag.exec(text);
            if (!firstMatch) return [];

            const afterFirstBegin = firstMatch.index + firstMatch[0].length;
            const braceMatch = text.substring(afterFirstBegin).match(/^\s*(?:\[.*?\])?\s*\{.*?\}/);
            if (!braceMatch) return [];

            contentStartIndex = afterFirstBegin + braceMatch[0].length;
            nestingLevel = 1;
            searchIndex = contentStartIndex;

            while (nestingLevel > 0 && searchIndex < text.length) {
                const nextBegin = text.indexOf('\\begin{tabular}', searchIndex);
                const nextEnd = text.indexOf('\\end{tabular}', searchIndex);

                if (nextEnd === -1) {
                    nestingLevel = 0;
                    contentEndIndex = -1;
                    break;
                }

                if (nextBegin !== -1 && nextBegin < nextEnd) {
                    nestingLevel++;
                    searchIndex = nextBegin + 1;
                } else {
                    nestingLevel--;
                    if (nestingLevel === 0) {
                        contentEndIndex = nextEnd;
                    }
                    searchIndex = nextEnd + 1;
                }
            }

            if (contentStartIndex === -1 || contentEndIndex === -1) {
                console.error("Could not find matching tabular environment.");
                return [];
            }

            let tableContent = text.substring(contentStartIndex, contentEndIndex);

            // --- Step 2: Remove inner tabular environments, keeping their content ---
            const innerTabularRegex = /\\begin{tabular}(?:\[.*?\])?\s*\{.*?\}([\s\S]*?)\\end{tabular}/g;
            const sanitizedContent = tableContent.replace(innerTabularRegex, (match, innerContent) => {
                // 内側のtabularの内容から改行('\\')をスペースに置換。
                const contentWithoutNewlines = innerContent.replace(/\\\\/g, ' ');
                return contentWithoutNewlines.trim();
            });


            // --- Step 3: Process the sanitized content (original logic) ---
            const rows = sanitizedContent.split(/\\\\/g);

            if (rows.length > 0 && rows[rows.length - 1].trim() === '') {
                rows.pop();
            }

            return rows.map(row => {
                return row.replace(/\\hline|\\toprule|\\midrule|\\bottomrule/g, '');
            })
                .filter(row => row.trim() !== '')
                .map(row => {
                    const processedRow = row.replace(/\\multicolumn\s*\{(\d+)\}\s*\{.*?\}\s*\{(.*?)\}/g,
                        (match, cols, content) => {
                            const colSpan = parseInt(cols, 10);
                            if (isNaN(colSpan) || colSpan < 1) return content;

                            const padding = ' & '.repeat(colSpan - 1);
                            return padding ? content + ' &' + padding : content;
                        }
                    );

                    return processedRow.split('&').map(cell => cell.trim());
                });
        }


        // --- ジェネレーター（2次元配列 -> 文字列） ---
        function generateMarkdown(data) {
            if (data.length === 0) return '';
            let markdown = '';
            // ヘッダー
            markdown += '| ' + data[0].join(' | ') + ' |\n';
            // 区切り
            markdown += '|' + data[0].map(() => ' --- ').join('|') + '|\n';
            // ボディ
            data.slice(1).forEach(row => {
                markdown += '| ' + row.join(' | ') + ' |\n';
            });
            return markdown;
        }

        function generateTex(data) {
            if (data.length === 0) return '';
            const cols = data[0].length;
            // 列の指定子をとりあえず全部 'c' (center) にする
            const colSpec = '{' + 'c'.repeat(cols) + '}';
            let tex = `\\begin{tabular}${colSpec}\n`;
            tex += ' \\hline\n';

            data.forEach((row, index) => {
                tex += ' ' + row.join(' & ') + ' \\\\\n';
                if (index === 0) { // ヘッダーの後
                    tex += ' \\hline\n';
                }
            });

            tex += ' \\hline\n';
            tex += '\\end{tabular}';
            return tex;
        }

    </script>

</body>

</html>